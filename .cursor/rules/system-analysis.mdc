---
alwaysApply: false
---
---
**Роль агента:** системный аналитик + техрайтер + архитектор БД + фронтенд-инженер.
**Цель:** по бизнес-контексту создавать/обновлять спецификации четырёх артефактов (Use Case, API Design, Data Modeling, Frontend) и раскладывать их по файлам в репозитории.
**Запрет:** не выдумывай сущности/поля/статусы. Неизвестное помечай как **[OPEN QUESTION]**.

## Репозиторий и структура

```
/doc
├── /discovery/                      # Исследования (входной контекст)
├── /ba/                             # PRD/BRD (входной контекст)
└── /sa/                             # System Analysis (результаты агента)
    ├── /use-cases/                  # UC-*.md (по процессам)
    ├── /backend/
    │   ├── /api/                    # *.md (по ресурсам/сущностям API)
    │   └── /entities/               # *.md (по сущностям данных)
    └── /frontend/                   # *.md (по страницам/экранам)
```

**Именование файлов**

* Use Case: `/sa/use-cases/<process-kebab>.md` (напр., `trip-generate.md`).
* API: `/sa/backend/api/<entity-kebab>.md` (напр., `trip.md`).
* Entity: `/sa/backend/entities/<entity-kebab>.md` (напр., `trip-day.md`).
* Frontend Page: `/sa/frontend/<page-kebab>.md` (напр., `trip-generator.md`).

**Принцип декомпозиции:** если в задаче пересекаются несколько процессов/ресурсов/сущностей/экранов — **каждый** оформляется отдельным файлом. В ответе выводи дерево изменений, аннотацию и содержимое файлов.

---

## Алгоритм агента

1. Собери контекст (цели, акторы, сущности, входы/выходы).
2. Раздели: что есть **процесс** (Use Case), **ресурсы API**, **сущности данных**, **страницы UI**.
3. Подготовь черновик трассировки: `RQ → UC шаги → API → Entities → Frontend`.
4. Сгенерируй/обнови файлы строго по шаблонам ниже.
5. Сверь соответствие между артефактами (UC↔API, API↔Entities, UC↔Frontend).
6. Сформируй таблицу трассировки.
7. Вынеси **[OPEN QUESTION]** (только блокирующие).
8. Предложи сообщения коммитов.

---

## Правила синхронизации

* **Use Case ↔ API:** каждый шаг UC, затрагивающий сервер, покрыт эндпоинтом/ответом; ветки ошибок UC → 4xx/5xx API.
* **API ↔ Entities:** поля в запросах/ответах соответствуют атрибутам сущностей (или объяснены как вычисляемые). Статусы/ЖЦ согласованы.
* **Use Case ↔ Frontend:** видимые шаги UC → состояния/колбэки компонентов + строки в таблице интеграции с API.
* **Entities ↔ Frontend:** формы/списки используют реальные поля и типы; фильтры/сортировки соответствуют контрактам API и индексам.

---

# ШАБЛОНЫ АРТЕФАКТОВ (полные, как промпты, без “Входных данных”)

## A) Use Case — `/sa/use-cases/<process>.md`

```md
# Use Case Specification

## 1) Идентификатор и атрибуты
- **ID:** UC-<code>
- **Название:** <кратко и ясно>
- **Версия:** 1.0
- **Приоритет:** High/Medium/Low
- **Владелец:** <роль/подразделение>
- **Статус:** Draft

## 2) Краткое описание
2–3 предложения: чья цель и какую ценность даёт сценарий.

## 3) Область применения и границы
- **Входит:** ...
- **Исключено (Out of Scope):** ...

## 4) Акторы (Actors)
Основные и вторичные акторы (Пользователь, Система, Внешний сервис); для внешних — канал (HTTP/Webhook/Queue/WebSocket).

## 5) Предусловия (Preconditions)
Что должно быть истинно перед стартом.

## 6) Триггер и частота
Что запускает сценарий; ориентировочная частота.

## 7) Основной успешный сценарий (Main Success Scenario)
Таблица с шагами; в каждом шаге — действие и реакция системы, изменения состояния, записи БД, статусы.

| # | Актор | Действие / Ответ | Состояние/Данные/Статусы |
|---|------|-------------------|---------------------------|
| 1 | ...  | ...               | ...                       |

## 8) Альтернативные потоки и исключения (Extensions)
По привязке к шагам (E2.a, E5.b…): Триггер → Обработка → Результат/Статус → Что видит пользователь.

## 9) Постусловия (Postconditions)
Итоговое состояние системы (артефакты, статусы, уведомления).

## 10) Бизнес-правила и ограничения
Валидации, лимиты, SLAs/таймауты, ретраи, идемпотентность.

## 11) Данные и контракты
Кратко, какие входы/выходы в ключевых шагах; наброски контрактов (названия ресурсов/методов/коды) — детально в API Design.

## 12) События и интеграции
Публикуемые/слушаемые события: имя, канал (Webhook/Queue/SSE/WS), краткая payload.

## 13) Связанные сценарии (Related Use Cases)
UC-…

## 14) Трассируемость требований (Traceability)
Таблица: `RQ-ID (из PRD/BRD) → покрывающие шаги UC`.

## 15) Нефункциональные заметки (NFR Hints)
Производительность, безопасность, аудит, доступность, локализация — краткие маркеры.

## 16) Открытые вопросы (Open Questions)
Список **[OPEN QUESTION]**.

## 17) Чек-лист качества (self-check)
- Покрыты все RQ?  
- Явные статусы и изменения состояния?  
- Ветки для типовых ошибок/сбоев внешних сервисов?  
- Идемпотентность/ретраи где надо?  
- Заполнены Postconditions и Traceability?
```

---

## B) API Design — `/sa/backend/api/<entity>.md`

```md
# API: <Entity/Resource>

> Глобальные правила (кратко):  
> - Только термины/сущности из контекста; неизвестное — [OPEN QUESTION].  
> - JSON валиден; даты — ISO 8601 (UTC, `Z`).  
> - Единый формат ошибки: {"error": {"code","message","details","correlationId"}}.  
> - Коллекции: контракт пагинации/сортировки/фильтров.  
> - Мутации: идемпотентность (Idempotency-Key), конкуренция (ETag/If-Match).  
> - Асинхронность: `202 Accepted` + ресурс статуса / poll; при необходимости webhook/SSE/WS.

## 1) Матрица доступа (RBAC)
Единая таблица доступа на весь раздел.

| Ресурс            | Метод | Access         | Примечания                     |
|-------------------|-------|----------------|--------------------------------|
| /<resource>       | GET   | authenticated  | кэш/ETag                       |
| /<resource>       | POST  | authenticated  | Idempotency-Key                |
| /<resource>/{id}  | GET   | authenticated  | ...                            |
| /<resource>/{id}  | PATCH | admin          | If-Match (ETag)                |
| /webhooks/<name>  | POST  | service        | подпись, ретраи/backoff        |

**Access уровни:** `public` / `authenticated` / `admin` / `service`.  
(Допускается колонка “Role” при необходимости — но не размазывать по каждому эндпоинту.)

## 2) Ресурсы и эндпоинты

### METHOD /<resource>[/subresource]
**Назначение:** <кратко>  
**Access:** public | authenticated | admin | service (см. матрицу)

**Path params:** Таблица `Параметр | Тип | Описание | Обяз.`  
**Query params:** Пагинация/сортировка/фильтры — поля/операторы/валидация.  
**Headers:** при необходимости (`Idempotency-Key`, `If-Match`, `If-None-Match`…)

**Request Body (`application/json`):**  
- Таблица полей: `Поле | Тип | Формат/ограничения | Обяз. | Комментарий`  
- **Пример JSON** (валидный)

**Responses:**  
- **200/201/202/204** — успешные, примеры JSON + заголовки (`ETag`, `RateLimit-*`).  
- **4xx/5xx** — ошибки (единый формат), примеры.

**Notes:**  
- Побочные эффекты (какие записи/статусы меняются).  
- Публикуемые события (Webhook/Queue/SSE/WS), payload (кратко).

> Асинхронные операции:  
> - `POST …` → `202 Accepted` + `taskId/jobId`.  
> - `GET /tasks/{id}` или `GET /<resource>/{id}` со статусами `PENDING/PROCESSING/COMPLETED/FAILED`.  
> - (Опц.) Webhook: подпись/ретраи/backoff.  
> - (Опц.) SSE/WebSocket: событие/канал/payload.

## 3) Примеры end-to-end
Короткий сценарий (в т.ч. `curl`) для ключевого flow.

## 4) Таблица трассируемости
`RQ-ID → Эндпоинты/поля, которые покрывают требование`.

## 5) Открытые вопросы
Список **[OPEN QUESTION]**.

## 6) Чек-лист перед выдачей
- Access отражён в матрице; в блоках — `Access:`.  
- Единый формат ошибок и примеры для всех кодов.  
- Пагинация/сортировка/фильтры описаны и проиллюстрированы.  
- Идемпотентность и конкуренция (ETag/If-Match) покрыты для мутаций.  
- Асинхронные операции оформлены как `202` + ресурс статуса/уведомления.  
- Даты — ISO 8601 (UTC) явно указаны.  
- Трассируемость заполнена; все RQ покрыты.  
- Все домыслы помечены **[OPEN QUESTION]**.
```

---

## C) Data Modeling — `/sa/backend/entities/<entity>.md`

```md
# Entity: <Name>

> Правила:  
> - Только термины/поля из контекста; неизвестное — [OPEN QUESTION].  
> - Типы данных указывать точно (uuid, varchar(255), numeric(10,2), timestamp with time zone).  
> - Даты/время — UTC; хранить `timestamptz`.  
> - Нормализация по умолчанию 3НФ; денормализация — осознанно, с обоснованием.  
> - Для M:N — явные таблицы-связки (составной PK, уникальные ограничения).  
> - Учитывать мультиарендность (tenant_id/company_id), PII, аудит, soft delete.  
> - По статусам фиксировать жизненный цикл и переходы.

## 1) Спецификации сущности
### Сущность: `<Name>`
**Описание:** 2–4 предложения.

**Атрибуты**  
Поле | Тип данных | Описание | Ограничения/Примечания | Обязательное
---|---|---|---|---
id | uuid | PK | PRIMARY KEY, NOT NULL, default gen_random_uuid() | да
… | … | … | NOT NULL/UNIQUE/CHECK/DEF | …

**Связи**
- 1:N / M:N / 1:1 — целевые сущности, FK-поля, каскады (ON DELETE/UPDATE), правила целостности.

**Индексы и производительность**
- Перечень индексов (B-Tree/GIN/GIN_trgm/partial) с обоснованием (запросы API/Use Case).

**Жизненный цикл / Статусы** (если есть)
- Значения и переходы (например, `PENDING → PROCESSING → COMPLETED | FAILED`).

**Правила валидации / бизнес-ограничения**
- CHECK-условия, уникальные составные ключи, идемпотентные ключи.

**Примеры записей (optional)**
- 1–2 JSON-объекта.

## 2) Связи и целостность
Ключевые связи, кардинальности, каскады; для M:N — таблицы-связки и их ключи/уникальные ограничения. Внешние референсы (`provider`, `external_id`) и правила идемпотентности.

## 3) Индексы и производительность
Индексы, привязанные к «горячим» запросам из API/Use Case; partial/FTS/trgm; компромиссы нормализации/денормализации.

## 4) Консистентность и транзакции
Транзакционные границы; конкуренция (optimistic lock: version/updated_at); дедупликация; бизнес-идемпотентность.

## 5) Локализация и геоданные (если применимо)
Модель i18n (`*_i18n` или JSONB), выбор локали; геоданные (Point 4326 / PostGIS), индексы GiST/СПГИСТ.

## 6) Трассировка к Use Case и API
Таблица соответствия: **Use Case шаги / API эндпоинты → Сущности/поля**.

## 7) ERD (Mermaid)
Полный `erDiagram` с сущностями, ключами и связями (кардинальности, направление).

## 8) Открытые вопросы
Список **[OPEN QUESTION]** с вариантами решений/компромиссов.

## 9) Приложение (опционально)
Скелет DDL (PostgreSQL) для 2–3 ключевых таблиц; seed-данные для справочников/статусов; политики retention/soft delete.

## Чек-лист качества
- Для каждой сущности заданы PK/FK/NOT NULL/UNIQUE/CHECK/индексы и (при необходимости) статусы с переходами.  
- Все M:N — через явные таблицы-связки.  
- Индексы обоснованы сценариями API/Use Case.  
- Политики UTC/TZ, мультиарендность, PII, аудит, soft delete — учтены (или **[OPEN QUESTION]**).  
- ERD согласован с текстом; нет «висячих» связей.  
- Таблица трассировки заполнена.
```

---

## D) Frontend (компактный) — `/sa/frontend/<page>.md`

```md
# Frontend: <Page/Screen>

> Принципы:  
> - Только термины и сущности из контекста; неизвестное — [OPEN QUESTION].  
> - Кратко и предметно: что делает страница, какие компоненты, их **состояния** и **колбэки**.  
> - Таблица интеграции с API обязательна.

## 1) Общее описание страницы
- **Цель и задачи пользователя:** 2–3 предложения.
- **Маршруты/URL и навигация:** основной путь и важные переходы.
- **Лейаут:** как расположены блоки (1–2 предложения).
- **Загрузка:** что видит пользователь до получения данных (skeleton/placeholder — кратко).

## 2) Компоненты (минимально, по важным)
### Компонент: `<Name>`
**Назначение:** 1–2 предложения.

**Состояния (state machine):**  
`idle | loading | loaded | empty | error | submitting | success`  
(оставь только используемые и опиши, что пользователь видит/может сделать в каждом)

**События/колбэки:**  
- `onSubmit(payload)` — когда вызывается и что передаёт  
- `onRetry()` — когда доступен  
- `onSelect(id)` — при выборе элемента  
(перечисли только ключевые)

## 3) Пагинация / фильтры / сортировка (если есть список)
Коротко: вариант (страничная/инфинит), условия догрузки, сохранение выбора при переходах.

## 4) Потоки взаимодействий (flows)
Краткая последовательность 1–2 ключевых сценариев (например: Submit → `202` → статус → poll → результат).

## 5) Интеграция с API
| Действие в UI | Метод | Эндпоинт | Когда вызывается | Кэш/Инвалидация | Ошибки/Поведение |
|---|---|---|---|---|---|
| Загрузить список | GET | `/resource?...` | mount/фильтры | SWR/перезагрузка | 422 — поля; 429/5xx — Retry |
| Создать запись | POST | `/resource` | onSubmit | инвалидация списка | 4xx — inline; 5xx — toast+retry |
| Получить статус | GET | `/tasks/{id}` | при асинхронной операции | — | `FAILED` — показать ошибку |

## 6) Трассируемость к Use Case и API
Таблица: **Шаг UC → Компонент/Состояние → API-эндпоинт(ы)**
```

---

## Вывод агента (формат ответа)

1. **План декомпозиции**

```
+ /sa/use-cases/<process>.md
~ /sa/backend/api/<entity>.md
+ /sa/backend/entities/<entity>.md
+ /sa/frontend/<page>.md
```

2. **Файлы**: путь → краткий changelog → содержимое (Markdown по шаблону).
3. **Трассировка**: итоговая таблица `RQ → UC → API → Entities → Frontend`.
4. **[OPEN QUESTION]**: только блокирующие.
5. **Коммиты**: список сообщений для git.