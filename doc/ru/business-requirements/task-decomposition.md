## Бэклог продукта: Localize MVP v1.0

### **Epic 1: Аутентификация пользователя (FR-01)**

#### User Story 1: Регистрация по Email
*   **История:** Как новый пользователь, я хочу создать аккаунт с помощью email и пароля, чтобы иметь возможность сохранять сгенерированные маршруты.
*   **AC:**
    1.  На странице регистрации есть поля "Email", "Пароль" и "Подтверждение пароля".
    2.  Система проверяет, что введенный email имеет корректный формат.
    3.  Система проверяет, что пароль содержит не менее 8 символов.
    4.  Система проверяет, что пароли в полях "Пароль" и "Подтверждение пароля" совпадают.
    5.  При попытке регистрации с уже существующим email система отображает ошибку "Пользователь с таким email уже существует".
    6.  После успешной регистрации пользователь автоматически авторизуется и перенаправляется на главный экран (дашборд).
*   **Story Points:** 3

#### Технические задачи:
*   `[Frontend]` Создать компонент страницы регистрации с формой (поля, кнопка, обработка ошибок).
*   `[Frontend]` Реализовать клиентскую валидацию полей формы.
*   `[Frontend]` Реализовать отправку запроса на бэкенд и обработку ответа (успех/ошибка).
*   `[Backend]` Создать эндпоинт `POST /api/auth/register`.
*   `[Backend]` Реализовать серверную валидацию данных (email, пароль).
*   `[Backend]` Реализовать логику хеширования пароля (bcrypt) и сохранения нового пользователя в БД.
*   `[Backend]` Реализовать генерацию JWT токена для сессии после успешной регистрации.
*   `[QA]` Написать тест-кейсы для сценариев успешной и неуспешной регистрации.

---
#### User Story 2: Вход по Email
*   **История:** Как зарегистрированный пользователь, я хочу входить в свой аккаунт с помощью email и пароля, чтобы получить доступ к своим сохраненным маршрутам.
*   **AC:**
    1.  На странице входа есть поля "Email" и "Пароль".
    2.  При вводе неверной пары email/пароль система отображает ошибку "Неверный логин или пароль".
    3.  При попытке входа с не существующим в системе email отображается та же ошибка.
    4.  После успешного входа пользователь перенаправляется на главный экран (дашборд).
*   **Story Points:** 2

#### Технические задачи:
*   `[Frontend]` Создать компонент страницы входа с формой.
*   `[Frontend]` Реализовать отправку запроса на бэкенд и обработку ответа.
*   `[Backend]` Создать эндпоинт `POST /api/auth/login`.
*   `[Backend]` Реализовать логику проверки email и сравнения хеша пароля.
*   `[Backend]` Генерировать и возвращать JWT токен в случае успеха.
*   `[QA]` Написать тест-кейсы для сценариев успешного и неуспешного входа.

---
#### User Story 3: Вход и регистрация через Google
*   **История:** Как новый или существующий пользователь, я хочу войти/зарегистрироваться через свой Google аккаунт, чтобы не вводить данные вручную и ускорить процесс.
*   **AC:**
    1.  На страницах входа и регистрации присутствует кнопка "Войти с помощью Google".
    2.  При нажатии на кнопку пользователь перенаправляется на стандартный экран аутентификации Google.
    3.  После успешной аутентификации в Google, если пользователь с таким email новый, для него создается аккаунт в системе.
    4.  После успешной аутентификации пользователь авторизуется в приложении и перенаправляется на главный экран.
*   **Story Points:** 5

#### Технические задачи:
*   `[Frontend]` Добавить кнопку "Войти с помощью Google" на формы входа/регистрации.
*   `[Frontend]` Интегрировать Google Sign-In for Websites SDK, настроить редирект.
*   `[Frontend]` Реализовать отправку токена от Google на бэкенд для верификации.
*   `[Backend]` Настроить проект в Google Cloud Console для получения Client ID и Client Secret.
*   `[Backend]` Создать эндпоинт `POST /api/auth/google`.
*   `[Backend]` Реализовать логику верификации токена от Google.
*   `[Backend]` Реализовать логику "найти или создать" пользователя в БД на основе данных от Google.
*   `[DevOps]` Добавить `GOOGLE_CLIENT_ID` и `GOOGLE_CLIENT_SECRET` в переменные окружения.
*   `[QA]` Протестировать полный цикл входа и регистрации через Google.

---
### **Epic 2: Генерация и просмотр маршрута (FR-02, FR-03)**

#### User Story 4: Генерация маршрута по текстовому запросу
*   **История:** Как путешественник, я хочу описать свои пожелания к поездке в текстовом поле, чтобы получить готовый, персонализированный маршрут.
*   **AC:**
    1.  На главном экране есть многострочное текстовое поле для ввода запроса.
    2.  Поле имеет ограничение в 1000 символов.
    3.  После нажатия на кнопку "Создать маршрут" и до получения ответа отображается индикатор загрузки (например, спиннер или анимация).
    4.  Если генерация занимает более 15 секунд, процесс прерывается и пользователю показывается сообщение об ошибке.
    5.  В случае технической ошибки со стороны AI-сервиса, пользователю показывается дружелюбное сообщение с предложением попробовать еще раз.
    6.  После успешной генерации пользователь перенаправляется на экран просмотра маршрута.
*   **Story Points:** 8

#### Технические задачи:
*   `[Frontend]` Создать главный компонент с текстовым полем и кнопкой.
*   `[Frontend]` Реализовать состояние загрузки (loading state).
*   `[Frontend]` Реализовать отправку запроса на бэкенд и обработку ответа (перенаправление или показ ошибки).
*   `[Backend]` Создать эндпоинт `POST /api/routes/generate`.
*   `[Backend]` Интегрировать API внешнего AI-сервиса (например, OpenAI API).
*   `[Backend]` Сконструировать системный промпт для AI, включающий запрос пользователя и инструкции по форматированию ответа.
*   `[Backend]` Реализовать парсинг и валидацию ответа от AI-сервиса для преобразования его в структурированные данные (JSON).
*   `[Backend]` Настроить таймауты для внешнего API-запроса.
*   `[DevOps]` Обеспечить безопасное хранение API-ключа для AI-сервиса.
*   `[QA]` Подготовить набор разнообразных запросов для тестирования качества и стабильности генерации.
*   `[QA]` Провести нагрузочное тестирование для проверки соблюдения требования в 15 секунд.

---
#### User Story 5: Просмотр сгенерированного маршрута
*   **История:** Как пользователь, я хочу видеть сгенерированный маршрут в удобном виде с разбивкой по дням и отображением на карте, чтобы легко понять и оценить свой план.
*   **AC:**
    1.  Экран просмотра разделен на две основные части: список событий и интерактивная карта.
    2.  Список событий сгруппирован по дням, переключение между днями реализовано через вкладки (tabs).
    3.  Внутри каждого дня отображается упорядоченный список локаций с указанием времени посещения.
    4.  На карте отображаются пины только для тех локаций, которые относятся к выбранному дню.
    5.  При клике на локацию в списке, соответствующий пин на карте центрируется и подсвечивается (например, увеличивается или меняет цвет).
    6.  При клике на пин на карте, соответствующий элемент в списке прокручивается в зону видимости и подсвечивается.
    7.  Интерфейс корректно отображается на мобильных, планшетных и десктопных устройствах.
*   **Story Points:** 5

#### Технические задачи:
*   `[Frontend]` Создать компонент страницы просмотра маршрута.
*   `[Frontend]` Реализовать компонент вкладок для навигации по дням.
*   `[Frontend]` Интегрировать библиотеку для работы с картами (например, Mapbox, Leaflet).
*   `[Frontend]` Реализовать логику отрисовки пинов на карте на основе данных о маршруте для активного дня.
*   `[Frontend]` Реализовать двустороннюю синхронизацию состояния (подсветку) между списком и картой.
*   `[Frontend]` Адаптировать верстку под разные размеры экранов (mobile-first).
*   `[Backend]` Убедиться, что эндпоинт генерации и эндпоинт получения маршрута возвращают данные в удобном для фронтенда формате (включая geo-координаты).
*   `[QA]` Проверить корректность отображения маршрута и интерактивности на всех брейкпоинтах.
*   `[QA]` Протестировать взаимодействие со списком и картой (клики, скролл).